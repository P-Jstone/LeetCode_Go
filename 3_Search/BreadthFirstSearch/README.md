# 广度优先搜索

<u>**广度优先搜索**</u>（breadth-first search，BFS）不同与深度优先搜索，它是一层层进行遍历的，因此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时按照“广”的方向进行遍历的，也常常用来处理最短路径等问题。

考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着“广”的方向前进的策略，队列顶端的元素变化过程为 [1]->[2->3]->[4]，其中方括号代表每一层的元素。

```
    1
   / \  
  2   3  
 /  
4  
```

这里要注意，深度优先搜索和广度优先搜索都可以处理可达性问题，即从一个节点开始是否能达到另一个节点。因为深度优先搜索可以利用递归快速实现，很多人会习惯使用深度优先搜索刷此类题目。实际软件工程中，笔者很少见到递归的写法，因为一方面难以理解，另一方面可能产生栈溢出的情况；而用栈实现的深度优先搜索和用队列实现的广度优先搜索在写法上并没有太大差异，因此使用哪一种搜索方式需要根据实际的功能需求来判断。

# BFS模板

实际上BFS类似于树的层序遍历，对于队列中的元素只要队列不为空就持续遍历队列中的元素，直到队列中没有元素或者找到满足条件的元素，跳出循环。

第一层不停循环遍历队列中的元素，第二层循环先统计队列中的元素个数，遍历处理当前队列中的元素并将处理过的元素出队，同时将元素周围层序遍历的元素入队。
```
func findBridge(grid [][]int, queue *[][]int) int {
	var res int
	for len(*queue) > 0 {
		res++
		for j := len(*queue); j > 0; j-- {
			x, y := (*queue)[0][0], (*queue)[0][1]
			*queue = (*queue)[1:]
			for k := 0; k < 4; k++ {
				nx, ny := x + dir[k][0], y + dir[k][1]
				if isInGrid(grid, nx, ny) {
					if grid[nx][ny] == 1 {
						return res
					}
					if grid[nx][ny] == 2 {
						continue
					}
					*queue = append(*queue, []int{nx, ny})
					grid[nx][ny] = 2
				}
			}
		}
	}
	return res
}
```

# 双向BFS

## 为啥需要双向BFS？

众所周知朴素BFS搜索时，每一层的搜索节点数量会爆炸级增加。假设每一次搜索都有 n 个新的状态，并假设从起点到目标路径长为 m，那就要搜索： <code>n+n<sup>2</sup>+n<sup>3</sup>+...+n<sup>m</sup></code> 个状态，状态数就是 <code>n<sup>m+1</sup></code> 数量级的！

以本题为例，每一次搜索最多可以有8个新的状态。这要是bfs搜索层数太深了的话，贫穷的复杂度小家哪里遭受得住这压迫啊！

所以「双向BFS」闪亮登场！

## 双向BFS是啥？

双向BFS就是同时从起点和终点两个方向开始搜索，一旦搜索到另一个方向已经搜索过的位置（或者说出现某个状态被两个方向均访问到了），就意味着找到了一条联通起点和终点的最短路径。

## 双向BFS好处具体是啥？

双向BFS同时从起点和终点两个方向进行搜索，呈「两面包夹芝士」向最短路中间的某一点汇集，在路径中点相遇。则双向BFS的状态数是 <code>2*n<sup>m/2+1</sup></code> 数量级的。
芜湖~就这样美滋滋的优化了复杂度！

## 双向BFS解题思路

双向BFS其实并不麻烦！

朴素BFS就是单向BFS，单向BFS需要一个队列来进行搜索，需要一个哈希表来解决重复搜索和记录搜索层数。

那双向BFS就需要「两个队列」来进行双向搜索！需要「两个哈希表」来分别解决各自方向的重复搜索和记录搜索层数（也是字符串转换次数）！

## 既然两个队列，那我每次该让哪个方向进行搜索啊？

为了尽量让两个方向均匀搜索，即尽量保持两个方向搜索前进进度差不多，所以每次进行BFS搜索时，选择容量较少的队列进行BFS搜索，扩充该队列。（容量较少的队列之所以容量少就是因为他曾经拿去bfs搜索的节点太废物了，另外一个方向的队列每次搜索可以带回来好几个新状态，而他这队列每次搜索一不小心就颗粒无收还推出去一个...所以我们要安慰下容量较少的队列让他多搜几次，免得这方向上止步不前）

当然，你选择两个方向一边搜索一次这样交替搜索也是可以的，只是会稍微慢一点点点点。

## BFS搜索什么时候结束？

结束分为：「双方向成功汇集」和「双方向无法汇集」两种。

1. 如果在某一个方向搜索过程中「搜索到另一个方向搜索过的节点」，说明找到了最短路径，搜索结束。
2. 如果「某一个队列空了」，但搜索还没结束，那说明从该方向搜穿了，没路可走了，都搜不到另一个方向搜索过的节点，即两个方向不可能有所汇集，也就是说两个节点之间无最短路，此时搜索也宣告结束。**无需把两个方向都搜到底。**



